{{ block title }}
		{{ if stage == "basic"}}
			Page 2: Round {{which_round}} 
		{{ elif stage == "HDA"}}
			Page 4: Round {{which_round}} 
		{{ elif stage == "HCA"}}
			Page 5: Round {{which_round}} 
		{{ elif stage == "HBA"}}
			Page 6: Round {{which_round}} 
		{{ elif stage == "HPRA"}}
			Page 7: Round {{which_round}} 
		{{ else }}
			Page 10: Round {{which_round}} 
		{{ endif }}
{{ endblock }}

{{ block content }}
	<head>
		<script src="//unpkg.com/force-graph"></script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
		<script>
			function cancel() {
				document.getElementById("id_to_be_removed").value = null;
				document.getElementById('confirm_block').style.display = "none";
				highlight_node.clear()
			}
		</script>


		<style>
		.outer {
		  display: flex;
		  justify-content: center;
		  align-items: center;
		}

		.middle {
		  display: flex;
		  flex-direction: column;
		}

		</style>
	</head>

	<body>
		{{ if stage == "basic"}}
			<div>
				接下來我們透過一個範例來讓您體會一下遊戲的過程！
			</div>
			<br/>
		
			<div>
				以下這個網絡圖，展示的是2001年9月11日劫機攻擊美國本土的蓋達組織恐怖份子關係圖。圖中每一個點是一位劫機犯，每一條線顯示他們曾經有通聯紀錄，因此推斷有密謀關係。
			</div>
			<br/>
		
			<div>
				現在請您開始每次挑選一個點（人物），直到這個恐怖份子的所有關係被移除為止，達成任務。
			</div>
			<br/>
		{{ elif stage == "HDA"}}
			<div>
				讓我們回到之前那個9/11劫機恐怖份子的合作網絡。這次我們把每一個人物（點），依據他們的「連結程度」（指標A）用顏色深淺區分，顏色越深的連結程度越高，越淺的越低。
			</div>
			<br/>
		
			<div>
				現在請您挑選一個點，像是顏色最深的那個點（人物），將之移除，看看移除之後對整個網絡所產生的效應。
			</div>
			<br/>
		{{ elif stage == "HCA"}}
			<div>
				同樣的9/11劫機恐怖份子的合作網絡。這次我們把每一個人物（點），依據他們的「距離長短」（指標B）用顏色深淺區分，顏色越深的點，平均而言與其他點之間的距離越短。
			</div>
			<br/>
		
			<div>
				現在請您挑選一個點，像是顏色最深的那個點（人物），將之移除，看看移除之後對整個網絡所產生的效應。
			</div>
		{{ elif stage == "HBA"}}
			<div>
				同樣的9/11劫機恐怖份子的合作網絡。這次我們把每一個人物（點），依據他們的「中介程度」（指標C）用顏色深淺區分，顏色越深的點，它的中介程度越高。
			</div>
			<br/>
		
			<div>
				現在請您挑選一個點，像是顏色最深的那個點（人物），將之移除，看看移除之後對整個網絡所產生的效應。
			</div>
			<br/>
		{{ elif stage == "HPRA"}}
			<div>
				同樣的9/11劫機恐怖份子的合作網絡。這次我們把每一個人物（點），依據他們的「重要程度」（指標D）用顏色深淺區分，顏色越深的點，它的重要性越高。
			</div>
			<br/>
		
			<div>
				現在請您挑選一個點，像是顏色最深的那個點（人物），將之移除，看看移除之後對整個網絡所產生的效應。
			</div>
		{{ else }}
			Page 10: Round {{which_round}} 
		{{ endif }}

		<div class="outer">
			<div class="middle">
			<div class="mb-3 _formfield">
				<label class="col-form-label" for="id_to_be_removed">
					請在以下的網絡圖中，挑選一個點，進行移除。
				</label>
				<div class="controls">
					<input type="number" class="form-control" inputmode="numeric" id="id_to_be_removed" min="0" name="to_be_removed" required="" value="" placeholder="尚未選擇任何節點">
					<input type="text" class="form-control" id="id_graph_layout" name="graph_layout" required="" value="" style="display: none;">
				</div>
				{{ formfield_errors 'graph_layout' }}
			</div>

			<div id="confirm_block" style="display: none;">
					<p>確定要選擇此節點嗎？</p>
					<p id ="info" style="display: block;"> </p>
					
					<button id="yes_button" class="otree-btn-next btn btn-primary" onclick="submit_Gdata()">
							是，前往下一頁。
					</button>

					<!-- Fake button -->
					<div id="no_button" class="otree-btn-next btn btn-primary" onclick="cancel()" 
							style="background-color: gray; border-color: gray;">
							否，取消。
					</div>         
			</div>

			<div id="graph" 
					style="border-color: black; border-width: 1px; border-style: solid; padding:5px; width:fit-content;"></div>

			<script>
				var prng = new Math.seedrandom('abcde');
				const gData = { nodes: {{nodes}}, links: {{links}} };
				gData.nodes.forEach(node => { node.fx = node.x; node.fy = node.y; });
				const stage = "{{stage}}";
				const tool = "{{tool}}";
				const degree_color = {{degree_color}};
				const closeness_color = {{closeness_color}};
				const betweenness_color = {{betweenness_color}};
				const page_rank_color = {{page_rank_color}};

				const degree_ranking = {{degree_ranking}};
				const closeness_ranking = {{closeness_ranking}};
				const betweenness_ranking = {{betweenness_ranking}};
				const page_rank_ranking = {{page_rank_ranking}};
				const NODE_R = 10;
				let highlight_node = -1;
				
				gData.nodes.forEach(node => { node.fx = node.x; node.fy = node.y; });

				const Graph = ForceGraph()
					(document.getElementById('graph'))
					.graphData(gData)
					.width(document.querySelector('.otree-body').offsetWidth)
					.height(window.innerHeight*0.4)
					.minZoom(1)
					.maxZoom(1)
					.linkWidth(2)
					.linkColor(link => "#000000")
					.linkVisibility(link => link["display"] == "False" ? false : true)
					.nodeVisibility(node => node["display"] == "False" ? false : true)
					.onNodeClick(node => {
						let info = ''

						document.getElementById("id_to_be_removed").value = node.id;
						document.getElementById('confirm_block').style.display = "block";
						if (stage == "basic" || (stage=="official" && tool == "no_help")) {
							document.getElementById('info').style.display = "none";
						}
						else if (stage == "HDA" || (stage=="official" && tool == "degree")){
							document.getElementById("info").innerHTML = `連結程度排名第 ${degree_ranking[node.id]} 高`
						}
						else if (stage == "HCA" || (stage=="official" && tool == "closeness")){
							document.getElementById("info").innerHTML = `連結程度排名第 ${closeness_ranking[node.id]} 高`
						}
						else if (stage == "HBA" || (stage=="official" && tool == "betweenness")){
							document.getElementById("info").innerHTML = `連結程度排名第 ${betweenness_ranking[node.id]} 高`
						}
						else if (stage == "HPRA" || (stage=="official" && tool == "page_rank")){
							document.getElementById("info").innerHTML = `連結程度排名第 ${page_rank_ranking[node.id]} 高`
						}
						document.getElementById('info').style.display = "block";

						highlight_node = node.id;
					})
					.nodeCanvasObject((node, ctx) => {
					// 預設的著色
					ctx.strokeStyle = '#568EA6';
					if (node.id == highlight_node) {
						ctx.fillStyle = "#B22222";
						ctx.strokeStyle = "#B22222";
					}
					else if (stage == "basic" || (stage=="official" && tool == "no_help")) {
						ctx.fillStyle = "#ffffff";
					}
					else if (stage == "HDA" || (stage=="official" && tool == "degree")){
						ctx.fillStyle = degree_color[node.id];
					}
					else if (stage == "HCA" || (stage=="official" && tool == "closeness")){
						ctx.fillStyle = closeness_color[node.id];
					}
					else if (stage == "HBA" || (stage=="official" && tool == "betweenness")){
						ctx.fillStyle = betweenness_color[node.id];
					}
					else if (stage == "HPRA" || (stage=="official" && tool == "page_rank")){
						ctx.fillStyle = page_rank_color[node.id];
					}
					else{
						ctx.fillStyle = "#ffffff";
					}

					ctx.beginPath(); ctx.arc(node.x, node.y, NODE_R, 0, 2 * Math.PI, false); ctx.closePath();
					ctx.fill()
					ctx.stroke()
				})
			Graph.d3Force('center', null);
			Graph.onEngineTick(() => Graph.zoomToFit(0, 10, node => true));
			</script>
			<script>
				function submit_Gdata() {
					data = new Array();
					for (var n of gData.nodes){
						data.push({id: n.id, x: n.x, y: n.y})
					}
					document.getElementById("id_graph_layout").value = JSON.stringify(data);
				}

			</script>
			</div>
		</div>
	</body>

{{ endblock }}
